<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Kubernetes on Acme of foolishness</title>
    <link>http://localhost:1313/tags/kubernetes/</link>
    <description>Recent content in Kubernetes on Acme of foolishness</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Damilola</copyright>
    <lastBuildDate>Wed, 02 Jul 2025 19:13:52 +0100</lastBuildDate><atom:link href="http://localhost:1313/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" /><icon>http://localhost:1313/logo.svg</icon>
    
    
    <item>
      <title>Deploying a Jenkins Server to a Kubernetes Cluster</title>
      <link>http://localhost:1313/posts/kubernetes/deploying-a-jenkins-server-to-a-kubernetes-cluster/</link>
      <pubDate>Wed, 02 Jul 2025 19:13:52 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/kubernetes/deploying-a-jenkins-server-to-a-kubernetes-cluster/</guid>
      <description><![CDATA[<h1 id="-project-2-deploying-jenkins-on-kubernetes-with-persistent-storage-minikube">üöÄ Project 2: Deploying Jenkins on Kubernetes with Persistent Storage (Minikube)</h1>
<blockquote>
<p><em>Part of the <strong>10 Kubernetes Projects in 10 Weeks</strong> challenge</em></p></blockquote>
<p>Welcome to the second project in my Kubernetes challenge! This time, we&rsquo;re deploying <strong>Jenkins</strong>‚Äîa powerful CI/CD automation server‚Äîon a <strong>Minikube Kubernetes cluster</strong>, and we‚Äôll focus on one crucial aspect: <strong>persistent storage</strong>.</p>
<p>Stateful apps like Jenkins need to store data across pod restarts‚Äîlike pipeline configurations, plugins, and credentials. We&rsquo;ll achieve that using <strong>Persistent Volumes (PV)</strong> and <strong>Persistent Volume Claims (PVC)</strong> in Kubernetes.</p>
<p>Let‚Äôs dive in! üèä‚Äç‚ôÇÔ∏è</p>
<hr>
<h2 id="-what-youll-learn">üß† What You&rsquo;ll Learn</h2>
<ul>
<li>How to deploy Jenkins in a Kubernetes cluster using Minikube</li>
<li>How to configure Persistent Volumes and Persistent Volume Claims</li>
<li>Why persistence is essential for stateful applications like Jenkins</li>
</ul>
<hr>
<h2 id="-prerequisites">üì¶ Prerequisites</h2>
<p>Before you start, make sure you have the following installed:</p>
<ul>
<li>‚úÖ <a href="https://minikube.sigs.k8s.io/docs/start/">Minikube</a></li>
<li>‚úÖ <a href="https://kubernetes.io/docs/tasks/tools/">kubectl</a></li>
<li>‚úÖ <a href="https://helm.sh/docs/intro/install/">Helm</a> (optional, but makes things easier)</li>
<li>‚úÖ Basic familiarity with Kubernetes concepts (Pods, Services, PVCs)</li>
</ul>
<hr>
<h2 id="-step-1-start-your-minikube-cluster">‚öôÔ∏è Step 1: Start Your Minikube Cluster</h2>
<p>Let&rsquo;s spin up a local Kubernetes cluster using Minikube.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>minikube start --driver<span style="color:#f92672">=</span>docker
</span></span></code></pre></div>]]></description>
      
    </item>
    
    
    
    <item>
      <title>Deploying a Static Website to a Kubernetes Cluster</title>
      <link>http://localhost:1313/posts/kubernetes/deploying-a-static-website-to-a-kubernetes-cluster/</link>
      <pubDate>Wed, 25 Jun 2025 21:05:38 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/kubernetes/deploying-a-static-website-to-a-kubernetes-cluster/</guid>
      <description><![CDATA[<p>As part of my commitment to building mastery in kubernetes, I&rsquo;m starting with something simple but foundational: deploying a static website on Kubernetes.</p>
<p>It&rsquo;s quite an overkill and there is almost no practical reason for hosting a static site in kubernetes, but the goal here is to get hands on experience with Kubernetes components specifically pods, deployments and services, which I consider to be the building blocks of any Kubernetes application.</p>
<h2 id="what-well-be-building">What We&rsquo;ll be Building</h2>
<p>We&rsquo;ll deploy a static site served by <a href="">caddy</a> on a local kubernetes cluster using <a href="">minikube</a>, at the end of this project, we should be able to tell:</p>
<ul>
<li>What a Pod is and how containers are run</li>
<li>How a Deployment can be used to manage Pods- How to expose our application to the external world with Services</li>
</ul>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li><a href="">Docker</a> or <a href="">Docker Desktop</a></li>
<li><a href="">minikube</a></li>
<li><a href="">kubectl</a></li>
<li><a href="">git</a></li>
<li>docker hub account</li>
</ul>
<p>The code for this project can be found in this <a href="">repo</a></p>
<h2 id="prepare-the-static-website">Prepare the Static Website</h2>
<p>We are going to be using a custom website for this project, any static website would do but this one here is a free open source example site that we will use for this project.</p>
<p>We have to build a docker image that bundles our site and server in one package and upload it to a container registry so our cluster can then pull from there.</p>
<p>We pull the example site from the repo or you can use a simple <code>index.html</code> file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/cloudacademy/static-website-example.git
</span></span></code></pre></div><p>Since we will be using caddy server, we need to create a configuration to tell the server how to serve our files.</p>
<p>We create a new file called <code>Caddyfile</code> with the following content</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Caddyfile" data-lang="Caddyfile"><span style="display:flex;"><span>:80
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">root</span> <span style="color:#a6e22e">*</span> <span style="color:#e6db74">/srv</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">file_server</span>
</span></span></code></pre></div><p>This tells the server to act as a file server, listening on port 80 and serving files in the /srv directory.</p>
<p>Then we create a <code>Dockerfile</code> which contains commands that will help build our image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Dockerfile" data-lang="Dockerfile"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> caddy:2.7.5-alpine</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /srv</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> static-website-example /srv<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> Caddyfile /etc/caddy/Caddyfile<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">EXPOSE</span><span style="color:#e6db74"> 80</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> [<span style="color:#e6db74">&#34;sh&#34;</span>, <span style="color:#e6db74">&#34;-c&#34;</span>, <span style="color:#e6db74">&#34;caddy run --config /etc/caddy/Caddyfile --adapter caddyfile&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>We then build our image and push to dockerhub.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker build -t k8s-static-website-example .
</span></span></code></pre></div><p>Before pushing to dockerhub we may need to authenticate</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker login
</span></span></code></pre></div><p>Follow the prompts to login and on successful login, push the newly built image to dockerhub</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker push &lt;username&gt;/k8s-static-website-example
</span></span></code></pre></div><p>With these out of the way, we can focus on kubernetes next.</p>
<h2 id="pods">Pods</h2>
<p>In kubernetes, pods are the smallest deployable units of compute. An application in a container runs in a pod. A pod can contain more than one container but it is usually recommended to run one container per pod.</p>
<p>Containers running in a pod share the same IP address and network namespace. To learn more about pods, please refer to the official guide and docs.</p>
<p>To define a pod, you can use the following yaml file</p>
<h2 id="deployments">Deployments</h2>
<h2 id="services">Services</h2>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Understanding Kubernetes and Cloud Native Architecture</title>
      <link>http://localhost:1313/posts/kubernetes/understanding-kubernetes-and-cloud-native-architecture/</link>
      <pubDate>Tue, 24 Jun 2025 17:00:04 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/kubernetes/understanding-kubernetes-and-cloud-native-architecture/</guid>
      <description><![CDATA[<p>Like many backend engineers, I have spent most of my time doing CRUD, writing APIs, database queries, engaging in pointless arguments about programming languages and so on. But I began to notice that most job descriptions for senior roles expected more than just programming and database skills.</p>
<p>Since the rise of cloud computing, understanding infrastructure management, DevOps skills and cloud-native experience are now becoming essential for a backend engineer.</p>
<p>This realization led me to take a meaningful step forward in my professional journey, learning <a href="https://kubernetes.io">Kubernetes</a>. I came across a <a href="https://cncf.io">CNCF</a> and <a href="https://andela.com">Andela</a> <a href="https://www.andela.com/blog-posts/andela-and-cncf-team-up-to-give-the-11-8b-kubernetes-market-30-000-new-players">partnership</a> offering to train developers in kubernetes which I did not let pass me by.
I got accepted into the first cohort of the program, took the <a href="https://training.linuxfoundation.org/training/kubernetes-and-cloud-native-essentials-lfs250/">LFS250 course</a> and within four weeks obtained my <a href="https://training.linuxfoundation.org/certification/kubernetes-cloud-native-associate/">KCNA</a> certification as a kubernetes noob.</p>
<p>This post is a reflection of what I learned, why it matters, and where I&rsquo;m headed next.</p>
<h2 id="what-even-is-cloud-native">What Even Is Cloud Native</h2>
<p>Before diving into kubernetes, I want to talk about cloud-native architecture. Cloud-native is more than just running applications in the cloud, but it is a set of technological and architectural principles and practices geared towards cost-efficiency, reliability and faster time-to-market.</p>
<p>Some of the core principles or philosophy of the cloud native architecture include:</p>
<ul>
<li>Containers as a unit of deployment.</li>
<li>Loosely coupled systems with microservices as the default design pattern.</li>
<li>Employing automation and CI/CD pipelines for fast, repeatable and reliable delivery of applications.</li>
<li>Dynamic orchestration of infrastructure using tools like kubernetes.</li>
</ul>
<p>The cloud native ecosystem is vast with all kinds of tools for monitoring, networking, storage and so on, but kubernetes is at the center of it all. You can read more on cloud native <a href="https://github.com/cncf/toc/blob/main/DEFINITION.md">here</a>.</p>
<h2 id="what-is-kubernetes">What Is Kubernetes</h2>
<p>Going by current trends, Kubernetes can be considered as the platform for deploying and managing modern applications.
Kubernetes is a <a href="">container orchestration</a> platform that automates the deployment, scaling, networking and self-healing of containerized applications.</p>
<p>In practice, Kubernetes takes your containerized workloads and ensures they&rsquo;re always running in the desired state, no matter what. If an application crashes, Kubernetes restarts it. If traffic spikes, it can add replicas to manage load. If a node dies, it reschedules your workloads to healthy nodes.</p>
<p>Containers are a very convenient and lightweight way to run applications for a lot of good reasons.</p>
<p>Before containers you had to run applications on virtual machines or physical servers, running more than one application on the same server would require that these two do not clash or interfere with each other in terms of resource usage for both software and hardware.</p>
<p>Consider a case where two different applications both need different versions of a system library, or one application consumes much of the available resources and cuases all other process to crashes, this is not ideal and we have to ensure that each application is isolated from the other.</p>
<p>Virtual machines allow you to isolate operating systems on the same hardware, so applications running in virtual machines are isolated and resource limits and constraints can be well defined.</p>
<p>The success of virtualization technology was the ability to run multiple operating systems while using same hardware, but the down side is it the operating system overhead makes it somewhat inefficient.</p>
<p>During restarts, you have to add boot times into consideration, the storage space used to install full operating systems on disk and as different applications have different resource requirements, it would be wasteful to run a static website in a virtual machine, compared to an e-commerce website.</p>
<p>Containers are like virtual machines in the sense they isolate processes, but unlike virtual machines, containers share the same underlying host operating system kernel. This makes them very lightweight and cheap to run.</p>
<p>Many organizations nowadays have multiple services, or multiple instances of the same service to spread load across these instances. Managing tens of containers manually is easy, but managing containers at scale gets very messy easily and we will see why.
When you deploy a containerized application, you need to setup networking, manage restarts when it crashes, update to new versions and scale your instances when demands are high.</p>
<p>Container orchestration is a solution to this problem at scale and kubernetes is a container orchestration system. It can help manage automatic deployments, scaling, fault tolerance and management of containerized applications.</p>
<h2 id="kubernetes-architecture">Kubernetes Architecture</h2>
<p>Kubernetes operates in a cluster which usually spans across multiple hosts or nodes. The cluster can be divided into two parts, the control plane  and the worker plane.
The control plane is the brain of the cluster, it manages container scheduling/placement to worker nodes, self-healing, deployments etc. The worker nodes run the containerized workloads.</p>
<p>Some of the major concepts in kubernetes are as follows:</p>
<ul>
<li>
<p>Pods: the smallest deployable units, often one container, sometimes more.</p>
</li>
<li>
<p>Deployments: manage the lifecycle of pods.</p>
</li>
<li>
<p>Services: expose your pods internally or externally.</p>
</li>
<li>
<p>Nodes &amp; Clusters: infrastructure components that run and manage workloads.</p>
</li>
<li>
<p>Control Plane vs Worker Nodes: the brain and the muscle of the cluster.</p>
</li>
</ul>
<p>Kubernetes is an absolute beast and is one of the most complex tools to learn in software engineering. One blog post cannot be enough to capture the depth of kubernetes. So I am going to start simple by building 10 simple projects that highlights the different parts of kubernetes.</p>
<p>I started this journey to grow beyond my backend bubble‚Äîand I&rsquo;m glad I did. Kubernetes and the cloud-native ecosystem opened up a whole new layer of infrastructure understanding that complements my developer skills.</p>
<p>If you&rsquo;re a backend engineer thinking about DevOps, cloud-native, or just trying to stay ahead in your career, I highly recommend learning Kubernetes.</p>
]]></description>
      
        <media:thumbnail url="http://localhost:1313/images/kubernetes-101-banner2.png" />
      
    </item>
    
    
  </channel>
</rss>
